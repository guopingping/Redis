Redis使用
==============================================================================
```
Redis开源，基于内存的结构化数据存储媒介，作为数据库、缓存服务或消息服务使用；
    具备LRU淘汰、事务实现及不同级别的硬盘持久化等能力，且支持副本集和通过Redis Sentinel实现的高可用方案，支持通过Redis Cluster实现数据自动分片；

    主要功能基于单线程模型实现，即Redis使用一个线程来服务所有的客户端请求；
    Redis采用非阻塞式IO，精细化各种命令的算法时间复杂度

    1.Redis是线程安全的（只有一个线程），所有操作是原子性的，不会因并发产生数据异常；
    2.Redis速度非常快（大部分时间复杂度为O(1）
    3.高耗时的Redis是危险的，占用唯一的一个线程的大量处理时间，导致所有请求会被拖慢；


Key ：

    注意事项：
        1.不要使用过长的key
        2.key短到缺失了可读性也是不好的
        3.最好使用统一的规范设计；eg：object-type：id：attr
        4.Redis允许的最大Key长度是512MB

String：
    INCR：将key对应的value值自增1，返回自增后的值（针对可转化为整型的String数据起作用)，时间复杂度O(1);
    INCRBY：自增指定的整型数值；
    DECR/DECRBY：自减；
    （都要求value为String，且可转化为64为符号的整型数字）

    eg：
    1.库存控制
        高并发场景下实现库存余量的精准校验，确保不出现超卖的情况；
    2.自增序列生成
        多个客户端南通市向redis申请自增序列，redis能够确保每个客户端得到的序列值或序列范围是全局唯一的，不会
        出现不同客户端得到了重复的序列值的情况；

List：
    LPUSH：向指定List的左侧(头部)插入一个或多个元素，返回插入后的List长度，时间复杂度O(N)，N插入元素的数量;
    RPUSH：右侧；
    LPOP：左侧移出，时间复杂度O(1)；
    RPOP：右侧
    LPUSHX、RPUSHX：区别如果key不存在，不会进行任何操作；
    LLEN：list的长度，时间复杂度O(1)；
    LRANGE：返回指定list中指定范围的元素，时间复杂度O(N)；
            尽可能控制一次获取的元素数量，一次获取过大范围List会导致延迟，同时对长度不可预知的List，避免使用LRANGE key0-1这样完整的遍历操作；
    
    注意：
        LINDEX：返回指定List指定index上的元素，index越界，返回nil；-1代表List最后一个位置，时间复杂度o(N)
        LSET：将指定index上的元素设置为value，越界返回错误，时间复杂度O(N),操作是头/尾，尾O(1);
        LINSERT：指定元素之前/之后插入一个新元素，返回List长度。
                指定元素不存在，返回-1；
                指定key不存在，不进行任何操作，时间复杂度O(N)

Redis的List用于实现队列；
    
阻塞式的操作命令：BLPOP、BRPOP 能够实现类似BlockingQueue能力，即List空时，阻塞该连接，有对象的时候再返回；

```